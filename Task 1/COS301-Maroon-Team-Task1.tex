\documentclass[a4paper,10pt]{article}

\usepackage[margin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{array}
\usepackage{hyperref}
\usepackage[all]{hypcap}
\usepackage{listings}
\lstdefinestyle{TerminalStyle}{
  language=bash,
  basicstyle=\small\sffamily,
  numbers=left,
  numberstyle=\tiny,
  numbersep=3pt,
  frame=tb,
  columns=fullflexible,
  linewidth=0.9\linewidth,
  xleftmargin=0.1\linewidth
}
\lstdefinestyle{HtmlStyle}{
  language=html,
  basicstyle=\small\sffamily,
  numbers=left,
  numberstyle=\tiny,
  numbersep=3pt,
  frame=tb,
  columns=fullflexible,
  linewidth=0.9\linewidth,
  xleftmargin=0.1\linewidth
}
\lstdefinestyle{OutputStyle}{
  language=html,
  basicstyle=\small\sffamily,
  frame=tb,
  columns=fullflexible,
  linewidth=0.9\linewidth,
  xleftmargin=0.1\linewidth
}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\title{\includegraphics[width=12cm]{Eeufeeslogo.jpg} \\
       Department of Computer Science \\
       University of Pretoria \\
       \vspace{0.5cm}
       Software Engineering\\
       COS301 MiniProject \\
       \vspace{0.5cm}
       \begin{large} \textbf{Team Maroon}\\ NavUP\end{large}}

\date{} 
\author{Bondjobo, Jocelyn (J) 	13232852 		\\
		Mweshi, George (G)		16394713		\\
		Letsoalo, Joseph (J)	15043844		\\
		Setoaba, Phuti (P)		13032616		\\
		Trivella, Camron (C)	14070970		\\
		Coetzer, Albert (A)		15244882		\\
}

\begin{document}
\maketitle
\thispagestyle{empty}
\clearpage

\newpage
\pagenumbering{roman}
\thispagestyle{empty}
\tableofcontents
\clearpage

\newpage

\pagenumbering{arabic}

\section{Introduction}

	\subsection{Purpose} 	\subsection{Scope} 
	\subsection{Overview} 

\section{Overall Description}

	\subsection{Product Perspective}
	
		\subsubsection{System Interfaces}
			Each component and system/subsystem in the overall program will need its own interface between its own\\				software and the bigger program. For instance, the crowd sourcing routines must be able to record and report a\\			density map to the main branch of the program that must then be able to be accessed and utilized by an analyzer\\			which must then return it to the main branch to be retrieved as needed for navigation by the user.\\
		\subsubsection{User Interfaces}
			The user interface must consist of an easily understandable and navigable GUI, simple enough for even the\\				most inexperienced to use. The different options and account information must be visible and responsive and the\\			navigation component must be clear and accurate. The user should intuitively know how to get from any point to\\			any other point in the program.\\
		\subsubsection{Hardware Interfaces}
			The hardware interface must allow the program to access and utilize systems on the device on which the program\\			is running, specifically the GPS system if the program uses it, the wireless network adapter to check for Wi-Fi\\			routers and signal strength, the screen to display information and the device used to make selections. The\\				hardware interface will be the backbone of the program, allowing directions and instructions to be communicated\\			to the user.\\
		\subsubsection{Software Interfaces}
			The routines by which the program will be able to call, run and interpret other software on the device being\\				used to run the program. The routines will, for example, utilize the software responsible for managing the\\ 				connection between the device and the Wi-Fi routers. This will co-exist with the hardware interface to make use\\			of the hardware on the device for the program.\\
		\subsubsection{Communications Interfaces}
			The communications interface will most likely be used to connect devices being used to run the program to\\				other devices being used to run the program. One of the uses for this will be in crowd sourcing density data of\\			the users to help effectively and intelligently create the most efficient instructions for a specific user or to\\			record and utilize the most common trends in user movements to predict behavior and increase efficiency.\\
		\subsubsection{Memory}
			Information such as maps, router positions and user identities will most likely need to be stored on a server\\ 			by the program administrators. Information gathered about the users, such as common routes, time spent using\\ 				the program, user information and any other data collected by the program should also be stored in the same\\ 				way.However, an alternative would be to store the information on the user’s device and report it to the server\\ 			when needed.\\   
		\subsubsection{Operations}
			The primary operation of the program will be directing students around the University of Pretoria’s main\\				campus, secondary operations may include crowd sourcing utilities and a rewards program. It should be possible\\			to store and retrieve information about a user’s movements in order to back trace if necessary.\\
		\subsubsection{Site Adaptation Requirements}
			The program should be available in a variety of language options.\\
		
		
	\subsection{Product Functions}
		1. Basic Functionality\\
			NavUp has basic funtionality that allows the user's current location to be determined indoors and outdoors. The user can further search for a location, save a location, navigate to a location and see the route in 3D. Zoom in or out capability is also available. Location markers  are there to help the user differentiate their starting point, destination as well as other locations. The application can also generate an time estimate that the user may take to get to their destination.\\
		\\
		2. Surveillance\\
			Through surveillance, NavUP is able to provide and visualise pedestrian traffic information on campus and further provide an alternative route if one is available to avoid pedestrian traffic. Another capability that can be achieved is to record the user's number of steps which can be used by the user to track their movement for fitness or leisure or by a third party to run competitions.\\
		\\
		3. Extra features\\
			The appliaction can give recommendations of locations on campus in accordance to the users interests and preferences. And Rate and review places on campus\\
			
	\subsection{User Characteristics}
		The application NavUp can expect to have three types of users; the registered student or staff member, the guest and the administrator.\\
		\\
			1. The registered student or staff member and guest user are expected to be able to provide a destination location in terms of name of the building or faculty and room.\\
			\\
			2. The registered student or staff member will be able to save a track record of movements, favourite locations.\\
			\\
			3. The guest will have limited functionality; hence will only be able to navigate from place to place.\\
			\\
			4. The administrator must be able to set goals and provide information regarding competitions to be facilitated through NavUp. This entails the award giving process either for attendance of an event or achieving the set number of steps.\\

	\subsection{Constraints}
	\subsection{Assumptions and Dependencies}

\section{Specific Acquirements}

	\subsection{External Interface Requirements}
	\subsection{Functional Requirements}
	\subsection{Performance Requirements}
	\subsection{Design Constraints		\\
		1. User Movement		\\
			Because user location changes, to account for the location of the user in a building with one/ weak  \\
			Wi-Fi connection will lead to failure in updating to user location.		\\
		2. Failure connection		\\
			Since the app uses Wi-Fi to find location and navigate if the user fails to connect to Tuks Wi-Fi \\
			at that moment the app will not work regardless of whether the user uses cellular network data.		\\
		3. Location in buildings 	\\
			Finding the current location of the user and displaying it on the app inside the buildings will \\
			be restricted since we don’t have the lay-out/map of all buildings.	\\
			
	}
	\subsection{Software System Attributes\\
		1.Availability 	\\
			NavUP app is available only in the Hatfield campus and also is the user is Wi-Fi connected. \\
			This app it is only functional only if the two above requirement are met.\\
		2.Interoperability \\
			NavUP app will uses google maps as lay-out of the campus map and gps to navigate through the\\
			campus to find shortest path. \\
		3.Reliability \\
			NavUP app functionality is reliable only in the campus and when the user is connected to Tuks Wi-Fi.\\
			Therefore fi user fails to connect to the Wi-Fi they won’t be any service for the user. Just like \\
			availability, reliability depends on the requiems of the app to be met.  \\
		4.Maintainability \\
			Since this is an app NavUP can undergo updates without affecting the users systems and gives a\\
			user an option to update when the update are available.\\
		5.Supportability\\
			NavUP does tell the user what is needed for it to function by letting the user know that Tuks\\
			Wi-Fi needed or required to be at Hatfield campus. \\

	
	}
	\subsection{Other Requirements}
	\subsubsection{Quality requirements}
	\subsubsubsection{Performance}
	\begin{enumerate}
	\item \textbf{Description} \\
	Application performance can be defined as the amount of work that can be accomplished by an application in question in a measured time interval. The time interval is normally measured in seconds, where the amount of work can be defined as the throughput, latency or data transmission time.
		\begin{itemize}
			\item \textbf{Throughput} \\
			The number of requests and responses which can be processed by the system in a given time interval for example the time the application takes to locate its user on the map using wifi access points and gps.
			\item \textbf{Latency and Data transmission time} \\
			A time interval measured as the time it takes to service a request such as to find the best route or path to guide the user to a certain destination. 
		\end{itemize}

		The aim for this system, is to increase the throughput and decrease the latency. As the developer has no control over the network medium used, he/she must aim for a minimal request and response payload as to decrease the data transmission time.
	\item \textbf{Justification} \\
	Our aim for this system is to increase throughput, decrease latency and data transmission time. This will ensure we have a system that is responsive at all times, including peak times and delivers an excellent user experience.
	\item \textbf{Requirements}
		\begin{itemize}
			\item Function calls must be timed and benchmarked and this data should be logged.
			\item Network responses should be cached on server side to lighten the load on the device.
			\end{itemize}
	\end{enumerate}
	\subsubsubsection{Reliability}
\begin{enumerate}
\item \textbf{Description} \\
The designed system needs to be accessible from both inside and outside builinds at the University of Pretoria campuses as well as from other networks, especially on other campuses on the TENET network. The system should be reliable in its accessibility.
\item \textbf{Justification} \\ 
The system must not be unreliable in that it crashes under large workloads for example when many users are actually using the application and some users get denied service during work critical times when workloads are high. This causes a detriment in user productivity. To ensure that the system can be used confidently as a tool to increase productivity and ease the work process, the development aim must be for the system to be as reliable and accessible as possible.
\item \textbf{Requirements}
	\begin{itemize}
		\item To enable access of data from the Android app even when offline such as preferences, events, etc..
		\item Hot swapping of system modules should not affect system service reliability.
	\end{itemize}
\end{enumerate}
\subsubsubsection{Scalability}
\begin{enumerate}
\item \textbf{Description} \\
Scalability refers to the application in question's ability to handle an above normal workload for exemple when many users are currently using the app as it must provide and visualise information related to pedestrian traffic on campus for example in the form of heat maps of user locations.
\item \textbf{Justification} \\
The system needs Scalability because it needs to support many users at the same time.
\item \textbf{Requirements}
	\begin{itemize}
		\item The system should be able to handle the growing amount of data or number of users using the app at the same time.
	\end{itemize}
\end{enumerate}
\subsubsubsection{Security}
\begin{enumerate}
\item \textbf{Description} \\
Security in application software refers to authentication, authorization, data security and accounting. Authentication refers to the systems' ability to provide a way of identifying a user, normally with our system it will identify its users anonymously from the device name.
\item \textbf{Justification} \\
Security is a important aspect of any software product. In terms of information security, we are concerned about integrity, availability, confidentiality and non-repudiation in that order. 

\item \textbf{Requirements}
	\begin{itemize}
		\item System should be resistant hacking as some people could use it to steal some personal information on the device about the user.
	\end{itemize}
\end{enumerate}
\subsubsubsection{Flexibility}
\begin{enumerate}
\item \textbf{Description} \\
Flexibility refers to the ability of the system to be changed dynamically either by hot swapping certain components in a live system or by extending the system with some kind of plugin for example if there are some new building added on campus it should able to be updated or extended on the data the device has. 
\item \textbf{Justification} \\
Flexibility is important for any system. A non-flexible system is restricted to using technologies that were hard coded into it, and this necessitates, at best, large scale refactoring every time an upgrade is available since new technologies need to be reintegrated, makes adding new features tedious, and risks the system becoming archaic. A flexible system requires minimum effort to upgrade and expand, allowing for the system to easily grow in usefulness and function beyond the original vision.
\item \textbf{Requirements}
	\begin{itemize}
	\item Modules should be decoupled from one another, allowing the system to be extensible without a break in service which is achieved by integrating new modules and swapping out existing ones. 
	\end{itemize}
\end{enumerate}
\subsubsubsection{Maintainability}
\begin{enumerate}
\item \textbf{Description} \\
The system is to be designed in such a way that it is easily updated, modified or extended by the client in the future. In order to achieve these requirements, design patterns and best practices such as coding style guides are normally used to ensure uniformity and modularity across the system.
\item \textbf{Justification} \\
Many systems require regular changes, not because they were poorly designed or implemented, but because of changes in external factors.
\item \textbf{Requirements}
	\begin{itemize}
		\item All code should be documented in the applicable language documentation framework, such as JavaDocs for a Java based system, etc.
		\item A coding style guide/manual should be set up and associated with the project, such that all developers use similar coding styles and conventions, to allow for more readable code that is easier to maintain.
		\item System should be separated in distinct, concise and independent modules relating to separate concerns, to allow for easier maintenance.
	\end{itemize}
\end{enumerate}
\subsubsubsection{Auditability/Monitorability}
\begin{enumerate}
\item \textbf{Description} \\
The system is to be designed to be verbose and transparent in its workings, and to ensure maximum data security, to allow role players to have insights into how the system is used and how it may be improved. These requirements are achieved by making the maximum amount of relevant data available to its users and by enforcing strict constraints on the data that is stored. 
\item \textbf{Justification} \\
This is an important process in Software Engineering, where all the informations must be correct so requiring all the developers to see who made changes and when so that consistency must be kept in order to keep the system's data accurate and reliable.
\item \textbf{Requirements}
	\begin{itemize}
		\item Data in the app should always be consistent. This implies that all data should adhere to constraints placed on the data by the data model, such as regex patterns, minimum and maximum length, non nullable fields, etc.
	\end{itemize}
\end{enumerate}

\subsubsubsection{Integrability}
\begin{enumerate}
\item \textbf{Description} \\
The system should allow for future external integration with other platforms such as security authentication providers, different map database to be loaded, etc.
\item \textbf{Justification} \\
The system necessitates integrability to allow for maximum usability, as the integrability of the system is directly related to how usable it is. To be usable, the system must allow for easy migration, not just from previous systems, but also to future systems and future data storage mediums. The usability is also largely determined by how well the back-end system integrates with front end clients, and which clients are supported.
\item \textbf{Requirements}
	\begin{itemize}
		\item The system should allow technology neutral importing and exporting of data.
		\item The back-end system should integrate with an Android mobile app clients.
		\item The system should be able to integrate with different back-end authentication services.
	\end{itemize}
\end{enumerate}

\clearpage
\section{Open Issues}
\subsection {GitHub Repository}
Team Maroon Repository: \url{https://github.com/josephbondjobo/COS301-Maroon-Team/tree/develop}

This repository contains:
\begin{enumerate}
\item All work done by team members.
\item \href{https://github.com/josephbondjobo/COS301-Maroon-Team/blob/develop/Intro/Contributors.md}{CONTRIBUTORS.md} file outlining which members where involved in which phases of the project.
\end{enumerate}



\newpage
\clearpage
\addcontentsline{toc}{section}{References}

\end{document}
